<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>MVC、MVP和MVVM的对比 | Vboar&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="架构," />
  

  <meta name="description" content="这篇博文我来介绍一下MVC、MVP和MVVM以及它们之间的对比。虽然这门课是移动互联网，但因为我本身是前端方向的，所以在这篇博客里前端会涉及得多一些，但无论是什么领域，MV*的核心思想是大致相同的。
为什么会出现MV*在上个世纪早些日子，当时的软件工程师还是一堆科学家，他们写代码的用途也大多是进行一些数学运算之类的操作，不会去设计一款多功能多用途的软件，因此往往采用结构化脚本式的方式来编程，就是一">
<meta property="og:type" content="article">
<meta property="og:title" content="MVC、MVP和MVVM的对比">
<meta property="og:url" content="http://kass.top/2016/05/06/mvc-vs-mvp-vs-mvvm/index.html">
<meta property="og:site_name" content="Vboar's Blog">
<meta property="og:description" content="这篇博文我来介绍一下MVC、MVP和MVVM以及它们之间的对比。虽然这门课是移动互联网，但因为我本身是前端方向的，所以在这篇博客里前端会涉及得多一些，但无论是什么领域，MV*的核心思想是大致相同的。
为什么会出现MV*在上个世纪早些日子，当时的软件工程师还是一堆科学家，他们写代码的用途也大多是进行一些数学运算之类的操作，不会去设计一款多功能多用途的软件，因此往往采用结构化脚本式的方式来编程，就是一">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-5/27446321.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-5/97927512.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/52794389.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/85296525.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/8256204.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/503637.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/77370370.jpg">
<meta property="og:image" content="http://vboar.qiniudn.com/16-5-6/50275008.jpg">
<meta property="og:updated_time" content="2016-05-08T04:43:53.761Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MVC、MVP和MVVM的对比">
<meta name="twitter:description" content="这篇博文我来介绍一下MVC、MVP和MVVM以及它们之间的对比。虽然这门课是移动互联网，但因为我本身是前端方向的，所以在这篇博客里前端会涉及得多一些，但无论是什么领域，MV*的核心思想是大致相同的。
为什么会出现MV*在上个世纪早些日子，当时的软件工程师还是一堆科学家，他们写代码的用途也大多是进行一些数学运算之类的操作，不会去设计一款多功能多用途的软件，因此往往采用结构化脚本式的方式来编程，就是一">
<meta name="twitter:image" content="http://vboar.qiniudn.com/16-5-5/27446321.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=eaf5ab1e" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal_style.css">
  

  

  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/series/"
            target="_self"
            >
            系列
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/project/"
            target="_self"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么会出现MV"><span class="toc-text">为什么会出现MV*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC"><span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SmallTalk-MVC"><span class="toc-text">SmallTalk MVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-S架构的MVC"><span class="toc-text">B/S架构的MVC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVP"><span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-text">MVVM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a>
  </div>



<div class="content content-post CENTER">
   <article id="post-mvc-vs-mvp-vs-mvvm" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">MVC、MVP和MVVM的对比</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.05.06</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Justin Wong</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>这篇博文我来介绍一下MVC、MVP和MVVM以及它们之间的对比。虽然这门课是移动互联网，但因为我本身是前端方向的，所以在这篇博客里前端会涉及得多一些，但无论是什么领域，MV*的核心思想是大致相同的。</p>
<h3 id="为什么会出现MV"><a href="#为什么会出现MV" class="headerlink" title="为什么会出现MV*"></a>为什么会出现MV*</h3><p>在上个世纪早些日子，当时的软件工程师还是一堆科学家，他们写代码的用途也大多是进行一些数学运算之类的操作，不会去设计一款多功能多用途的软件，因此往往采用结构化脚本式的方式来编程，就是一个简单的获取输入、得到输出的过程。这时候的代码没有任何架构、任何分层，操作一般都是依靠命令行，根本没有UI可言。因为当时程序的特点就是功能单一、管理单一、入口单一，所以并不需要费太大力气就可以编写出一个很好的程序。</p>
<p>但是，老师上课也说过，需求是影响架构一个非常重要的因素。随着计算机和互联网的发展，需求也在不断地变化，用户也在发生变化，人们需要的是功能繁杂、管理统一、多入口的软件，软件的操作也从命令行逐渐转换到易用性更好的用户界面上了。但如果再采用之前结构化脚本式的方式来编码，则代码将变得非常混乱和难以维护，所以才会出现UI代码和业务逻辑代码分离的架构，UI和业务逻辑分离之后，协同完成软件操作。</p>
<p>随着软件和互联网行业的高速发展，需求也变得越来越庞大，那么响应的解决方案也会越来越庞大，编码也变得越来越复杂，这时候就更需要对代码模块进行细分。如何细分就涉及到哪个模块应该做哪些事情，即模块的职责分离。很简单的一个思路就是，开发图形界面应用程序时，把管理用户界面称为View，把程序的数据（数据抽象）称为Model。View和Model分层之后，View和Model之间如何粘合，View如何同步Model的变化，这就是<code>MV*</code>中的<code>*</code>在这方面有差异的地方了，不同的<code>MV*</code>对此的处理方式不同。常见的<code>MV*</code>架构模式有：MVC、MVP和MVVM。</p>
<p><img src="http://vboar.qiniudn.com/16-5-5/27446321.jpg" alt=""></p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="SmallTalk-MVC"><a href="#SmallTalk-MVC" class="headerlink" title="SmallTalk MVC"></a>SmallTalk MVC</h4><p>SmallTalk MVC是一种最原始的经典MVC，一般是指桌面软件的MVC。SmallTalk MVC把应用程序分为View、Model和Controller。其中View是用户界面，Model是数据以及处理业务逻辑，而Controller的职责是进行View和Model之间的协作的应用逻辑。</p>
<p>下图是View、Model和Controller之间的依赖关系图。如下图所示，View和Controller之间可以相互依赖，而View和Controller都依赖Model。</p>
<p><img src="http://vboar.qiniudn.com/16-5-5/97927512.jpg" alt=""></p>
<p>SmallTalk MVC的架构图如下图所示。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/52794389.jpg" alt=""></p>
<p>SmallTalk MVC的具体流程是：</p>
<ul>
<li>用户对View（用户界面）进行操作后，View会捕获到这个操作，然后把处理该操作的控制权转移给Controller；</li>
<li>Conttroller会对来自View的数据进行预处理，判断并决定调用哪个Model的接口；</li>
<li>Controller调用Model的接口后，Model执行相关的业务逻辑和更新数据；</li>
<li>当Model发生变更时，Model会通过观察者模式通知View自己发生了变更，然后View收到变更消息后就向Model请求最新的数据并且更新界面。</li>
</ul>
<h4 id="B-S架构的MVC"><a href="#B-S架构的MVC" class="headerlink" title="B/S架构的MVC"></a>B/S架构的MVC</h4><p>随着互联网的发展，C/S架构的客户端软件已经不能满足需求了，于是B/S架构的网页就火了起来，B/S架构的MVC是经典MVC的变种，并不能称之为严格的MVC。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/85296525.jpg" alt=""></p>
<p>结合上图可以得知B/S架构的MVC的具体流程如下：</p>
<ul>
<li>用户（浏览器）向服务器发出一个HTTP请求后，Web服务器根据URL进行路由分发，将控制权交给响应的Controller；</li>
<li>然后Controller执行响应的应用逻辑并对Model进行操作。Model执行业务逻辑后，Controller用Model的数据去渲染响应的View，然后将View返回给用户。</li>
</ul>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP模式是MVC模式的一种变种和进化，主要表现在Model、View和Presenter（原Controller）之间依赖关系的不同，如下图所示。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/8256204.jpg" alt=""></p>
<p>MVP的关键点在于切断了View和Model之间的联系，即打破了View对于Model的依赖，让View只与Presenter进行交互，这样可以减少在需求变化中需要维护的对象的数量。</p>
<p>MVP的架构图如下图所示。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/503637.jpg" alt=""></p>
<p>MVP的具体流程如下：</p>
<ul>
<li>用户对View（用户界面）进行操作后，View会捕获到这个操作，然后把处理该操作的控制权转移给Persenter；</li>
<li>然后Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；</li>
<li>Model执行相应的业务逻辑和更新数据后，通过观察者模式告知Presenter（MVC模式中是View）自己信息的变更，然后Presenter收到来自Model的变更消息后，通过View通过的接口来更新界面。</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM模式可以说是MVP模式的一种改良。MVVM即Model、View、ViewModel，其中ViewModel即视图的模型，它的含义包括了领域模型和视图的状态，可以把ViewModel简单理解为页面上所显示的内容的数据抽象。Model、View和ViewModel之间的依赖关系如下图所示。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/77370370.jpg" alt=""></p>
<p>MVVM的架构图如下所示。</p>
<p><img src="http://vboar.qiniudn.com/16-5-6/50275008.jpg" alt=""></p>
<p>MVVM的调用流程基本上是和MVP一致的，不过在MVVM的ViewModel中有一个Binder，在MVP中Presenter负责View和Model之间的数据同步，而在MVVM中该任务交给Binder处理。当ViewModel执行应用逻辑并操作Model、Model数据发生变更时，Binder会自动把数据更新到View上；当用户对View进行操作时，Binder也自动把数据更新到Model上，即数据的双向绑定，实现界面的实时渲染和数据的实时更新。只要显式地指明View显示的数据对应的是Model哪一部分，Binder就能自动完成View和Model的同步。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="external">界面之下：还原真实的MV*模式 - livoras</a></li>
<li><a href="http://www.cnblogs.com/indream/p/3602348.html" target="_blank" rel="external">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a></li>
<li><a href="https://segmentfault.com/q/1010000000336459" target="_blank" rel="external">对 MVC 和 MVP 模式的疑惑 -  segmentfault</a></li>
<li><a href="https://segmentfault.com/a/1190000003927200" target="_blank" rel="external">Android MVP模式 简单易懂的介绍方式 -  Kaede</a></li>
</ul>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/series/"
              target="_self"
              >
              系列
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/project/"
              target="_self"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="" data-title="MVC、MVP和MVVM的对比" data-url="http://kass.top/2016/05/06/mvc-vs-mvp-vs-mvvm/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"vboar"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
